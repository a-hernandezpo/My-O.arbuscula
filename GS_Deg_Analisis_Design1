# nolint start: line_length_linter

source("setup.R") #este comando permite acelerar la corrida del código inicial

## Running DESeq2
dds<-DESeq2::DESeqDataSetFromMatrix(countData = cts, colData = coldata, design=~ Genet + SymbiontState)

#Si se cambia el orden de los factores en el diseño, los resultados de la comparación cambiarán. 
# podemos probar con: design=~SymbiontState+Genet  o  design=~SymbiontState (sin tener en cuenta el genotipo)

# pre-filtering to remove low count genes 
dim(dds) #25649
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dim(dds) #25428

ddsMF<-DESeq2::DESeq(dds) #desarrollo lit de DESeq2
resMF<-results(ddsMF) #resultados se guardan en nueva variable ("resultados Modelo Final")
resMF #DataFrame with 25428 rows and 6 columns

summary(resMF) #resume el resultado de la expresión diferencial de genes
# out of 25428 with nonzero total read count
# adjusted p-value < 0.1                   umbral de significancia que estoy usando
# LFC > 0 (up)       : 153, 0.6% Log2      Fold Change positivo (más expresión en la condición de interés vs control)
# LFC < 0 (down)     : 48, 0.19%           Log2 Fold Change negativo (menos expresión)
# outliers [1]       : 0, 0%
# low counts [2]     : 0, 0%               (mean count < 1)
# 153 UP + 48 DOWN = 201 genes significativos


# standard p value less that 0.05
sum(resMF$pvalue<0.05, na.rm=TRUE) # 1453

sum(resMF$padj<0.05, na.rm=TRUE) # si padj<0.05 = 163       si padj<0.1 = 201
conds05<-filter(as.data.frame(resMF), pvalue<0.05) 

write.table(resMF, file="GS Sym_vs_Apo_collapsed.txt", sep="\t", quote=F)
valState=cbind(resMF$pvalue, resMF$padj) #adjusted p values
head(valState)
colnames(valState)=c("pval.state", "padj.state")
rownames(valState)<-rownames(resMF)



# transform the data for plotting 
rlogMF=rlogTransformation(dds, blind=TRUE) 
rld=assay(rlogMF)
colnames(rld)<-paste(coldata$Genet, coldata$SymbiontState, sep="_")

rldpvals=cbind(rld,valState)
#head(rldpvals)
#dim(rldpvals)

table(complete.cases(rldpvals))

rld_data<-as.data.frame(rldpvals)
#View(rld_data)

##### Heat map of degs0 
adjpval=0.05 # FDR cutoff
conds=filter(rld_data, padj.state<adjpval)

# remove pval data 
degs=conds[,1:10]
degs$contig<-rownames(degs)
gg$contig <- gsub("isogroup", "", gg$contig)
degs<-left_join(degs, gg, by="contig") # add in genenames from annotations file
degs$genename<-sub("\\..*", "", degs$genename)
degs$genename <- sub("OS=.*$", "", degs$genename) # quitar info extra de genename
genets<-rep(c("A","B", "C", "D", "F"), 2)

degs$genename[is.na(degs$genename)]<-"unknown" #NA to "unknown"

View(degs)
head(degs)
dim(degs)
# Si padj<0.05 Hay 163 filas y 12 NA.
# Si padj<0.1 Hay 201 filas y 60 NA.

degs$genename <- as.factor(degs$genename)
levels(degs$genename)  
# Si padj<0.05 Hay Hay 99 niveles de genename 
# Si padj<0.1 Hay 140 niveles de genename (140 genes anotados diferentes)


degs_plot<-filter(degs, genename!="unknown")

#Para crear todos los gráficos de este script, se utiliza el siguiente comando:
source("GS_CreatePlots.R") #llama al script para crear los gráficos.







#generate the heats data for GOWMU
heats<-mutate(as.data.frame(resMF),negP=-log(pvalue))
heats<-mutate(heats,signedlogP=case_when(log2FoldChange<0 ~ negP*-1, log2FoldChange>0 ~ negP))
heats$genes<-rownames(resMF)
heats<-select(heats, signedlogP, genes)
heats<- heats[,c("genes", "signedlogP")]
write.table(heats, "PVals_GOWMU_Collapsed.csv", sep=",", row.names = FALSE, quote=FALSE)

# two columns of comma-separated values: gene id, continuous measure of significance. 
input="PVals_GOWMU_Collapsed.csv"
goAnnotations="coral_gene_GOannot.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. 
goDatabase="go.obo"
#download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")

#Biological Processes
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=10,   # a GO category should contain at least this many genes to be considered, was increased from default due to the large number of BP GO terms that were significant
           clusterCutHeight=0.35  # cutoff in relatedness of GO terms to merge categories, was increased from default due to the large number of BP GO terms that were significant
           )





           

# Plotting results
quartz()
results_BP=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
                  level1=0.01, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.(italic font)
                  level2=0.001, # FDR cutoff to print in regular (not italic) font.
                  level3=0.00001, # FDR cutoff to print in large bold font.
                  txtsize=0.8,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
                  treeHeight=0.4, # height of the hierarchical clustering tree
                  colors=c("#35978F","#BF812D","#01665E","#8C510A") # first color is down reg, big and middle font color, then up reg big and middle font, then down italic, then up reg italic. 
)
# Fig S4
quartz.save(file="FigS4.png",type="png", width = 8, height = 80, dpi = 300 )
# Table S2 
write.csv(results_BP, file="TableS2.csv", quote=TRUE, row.names = TRUE)


goDivision="MF" # either MF, or BP, or CC
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=10,
           clusterCutHeight=0.25)

# Plotting results
quartz()
results_MF=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=-log(0.05,10),
                  level1=0.01, # italic font
                  level2=0.001, # FDR cutoff to print in regular (not italic) font.
                  level3=0.00001, # FDR cutoff to print in large bold font.
                  txtsize=0.8,    
                  treeHeight=0.4, 
                  colors=c("#35978F","#BF812D","#01665E","#8C510A") # first color is down reg, big and middle font color, then up reg big and middle font, then down italic, then up reg italic. 
)
# Fig S5
quartz.save(file="FigS5.png",type="png", width = 8, height = 40, dpi = 300, bg="white")
#Table S3
write.csv(results_MF, file="TableS3.csv", quote=TRUE, row.names = TRUE)

goDivision="CC" # either MF, or BP, or CC

gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=5,
           clusterCutHeight=0.25)

quartz()
results_CC=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=-log(0.05,10),
                  level1=0.01, # italic font
                  level2=0.001, # FDR cutoff to print in regular (not italic) font.
                  level3=0.00001, # FDR cutoff to print in large bold font.
                  txtsize=0.8,    
                  treeHeight=0.4, 
                  colors=c("#35978F","#BF812D","#01665E","#8C510A") # first color is down reg, big and middle font color, then up reg big and middle font, then down italic, then up reg italic. 
)
# Fig S6
quartz.save(file="FigS6.png",type="png", width = 4, height = 20, dpi = 300, bg="white")
#Table S4
write.csv(results_CC, file="TableS4.csv", quote=TRUE, row.names = TRUE)












# nolint end