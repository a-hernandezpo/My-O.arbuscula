# nolint start: line_length_linter

source("setup.R") #este comando permite acelerar la corrida del código inicial

## Running DESeq2
dds<-DESeq2::DESeqDataSetFromMatrix(countData = cts, colData = coldata, design=~ Genet + SymbiontState)

# pre-filtering to remove low count genes 
dim(dds) #25649
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dim(dds) #25428

ddsMF<-DESeq2::DESeq(dds) #desarrollo lit de DESeq2
resMF<-results(ddsMF) #resultados se guardan en nueva variable ("resultados Modelo Final")
resMF #DataFrame with 25428 rows and 6 columns

# design=~ Genet + SymbiontState
summary(resMF) #resume el resultado de la expresión diferencial de genes
# out of 25428 with nonzero total read count
# adjusted p-value < 0.1                   umbral de significancia que estoy usando
# LFC > 0 (up)       : 153, 0.6% Log2      Fold Change positivo (más expresión en la condición de interés vs control)
# LFC < 0 (down)     : 48, 0.19%           Log2 Fold Change negativo (menos expresión)
# outliers [1]       : 0, 0%
# low counts [2]     : 0, 0%               (mean count < 1)
# 153 UP + 48 DOWN = 201 genes significativos


# standard p value less that 0.05
sum(resMF$pvalue<0.05, na.rm=TRUE) # 1453

sum(resMF$padj<0.05, na.rm=TRUE) # si padj<0.05 = 163       si padj<0.1 = 201
conds05<-filter(as.data.frame(resMF), pvalue<0.05) 

write.table(resMF, file="GS Sym_vs_Apo_collapsed.txt", sep="\t", quote=F)
valState=cbind(resMF$pvalue, resMF$padj) #adjusted p values
head(valState)
colnames(valState)=c("pval.state", "padj.state")
rownames(valState)<-rownames(resMF)

# transform the data for plotting 
rlogMF=rlogTransformation(dds, blind=TRUE) 
rld=assay(rlogMF)
colnames(rld)<-paste(coldata$Genet, coldata$SymbiontState, sep="_")

rldpvals=cbind(rld,valState)
table(complete.cases(rldpvals))

rld_data<-as.data.frame(rldpvals)


##### Heat map of degs
adjpval=0.05 # FDR cutoff
conds=filter(rld_data, padj.state<adjpval)

# remove pval data 
degs=conds[,1:10]
degs$contig<-rownames(degs)
gg$contig <- gsub("isogroup", "", gg$contig)
degs<-left_join(degs, gg, by="contig") # add in genenames from annotations file
degs$genename<-sub("\\..*", "", degs$genename)
degs$genename <- sub("OS=.*$", "", degs$genename) # quitar info extra de genename
genets<-rep(c("A","B", "C", "D", "F"), 2)

degs$genename[is.na(degs$genename)]<-"unknown" #NA to "unknown"

head(degs)
dim(degs) # 163 filas y 12 columnas (si padj<0.05)


# Convertir las funciones de cada gen en "niveles" para poder graficarlas después:
degs$genename <- as.factor(degs$genename)
levels(degs$genename)  
# Si padj<0.05 Hay Hay 99 niveles de genename 
# Si padj<0.1 Hay 140 niveles de genename (140 genes anotados diferentes)

degs_plot<-filter(degs, genename!="unknown")

# Convertir a data frame
df_volc <- as.data.frame(resMF)
df_volc$gene <- rownames(df_volc)

# Eliminar NA en padj
df_volc <- df_volc[complete.cases(df_volc$padj), ]

#Volcano plot:

# Unir los dataframes usando merge con las columnas correctas
# df_volc$gene debe coincidir con degs$contig
df_volc <- merge(df_volc, 
                 degs[, c("contig", "genename")],
                 by.x = "gene",      # Columna en df_volc
                 by.y = "contig",    # Columna en degs
                 all.x = TRUE)       # Mantener todos los genes de df_volc


# Convertir genename de factor a character
df_volc$genename <- as.character(df_volc$genename)

print(head(df_volc[!is.na(df_volc$genename), c("gene", "genename")], 10))

# Crear label: usar genename si no es NA y no es "unknown"
df_volc$label <- ifelse(!is.na(df_volc$genename) & 
                         df_volc$genename != "unknown",
                       df_volc$genename,  # Ahora será el texto, no el nivel
                       df_volc$gene)

# Crear columna de significancia
df_volc$threshold <- "NS"
df_volc$threshold[df_volc$padj < 0.1 & df_volc$log2FoldChange > 2] <- "Up"
df_volc$threshold[df_volc$padj < 0.1 & df_volc$log2FoldChange < -2] <- "Down"



# Filtrar genes significativos (padj < 0.1)
res_sig <- subset(resMF, padj < 0.1)

# Convertir a dataframe y agregar nombres de genes como columna
df_sig <- as.data.frame(res_sig)
df_sig$gene <- rownames(df_sig)

# Renombrar columna para hacer merge (igual que en tu volcano plot)
df_sig$contig <- rownames(df_sig)

# Hacer merge con la información de funciones de gg
df_sig <- merge(df_sig, 
                degs[, c("contig", "genename")],
                by = "contig",
                all.x = TRUE)

# Convertir genename de factor a character
df_sig$genename <- as.character(df_sig$genename)

# Si no hay anotación, poner "unknown"
df_sig$genename[is.na(df_sig$genename)] <- "unknown"

# Crear dataframe UP (LFC > 0)
df_up <- subset(df_sig, log2FoldChange > 0)
# Ordenar columnas: gen, función, pvalor, padj, LFC
df_up <- df_up[, c("gene", "genename", "pvalue", "padj", "log2FoldChange")]
colnames(df_up) <- c("Gene", "Function", "pvalue", "padj", "log2FoldChange")

# Crear dataframe DOWN (LFC < 0)
df_down <- subset(df_sig, log2FoldChange < 0)
df_down <- df_down[, c("gene", "genename", "pvalue", "padj", "log2FoldChange")]
colnames(df_down) <- c("Gene", "Function", "pvalue", "padj", "log2FoldChange")

# Mostrar dimensiones
cat("UP genes:", nrow(df_up), "\n")
cat("DOWN genes:", nrow(df_down), "\n")

# Ver primeros genes de cada dataframe
head(df_up)
head(df_down)

if (!require("openxlsx")) install.packages("openxlsx")
library(openxlsx)

# Alternativa: ambos en un solo archivo Excel con pestañas diferentes
write.xlsx(list(UP = df_up, DOWN = df_down), 
           file = "genes_diferenciales.xlsx",
           colNames = TRUE, rowNames = FALSE)


#Para crear todos los gráficos de este script, se utiliza el siguiente comando:
#source("GS_CreatePlots.R") #llama al script para crear los gráficos.



##Gene Ontology analysis with GOWMU:

# Primero, queremos unir los resultados de DESeq2 con los términos de GO para el posterior análisis en Gene Ontology.

GS_degs_IDs <- data.frame(
    contig = degs$contig
)
View(GS_degs_IDs) # La tabla tiene una columna llamada "contig" con los IDs de los 163 DEGs.
dim(GS_degs_IDs) #163 filas y 1 columna

AnotacionesGO <- read.delim("data/coral_gene_GOannot.tab", sep = "\t", header = FALSE)

colnames(AnotacionesGO) <- c("contig", "Terminos_GO")

GS_degs_GO <- inner_join(
    GS_degs_IDs,          # Tabla de origen (163 DEGs)
    AnotacionesGO,     # Tabla de destino (Anotaciones de todo el genoma)
    by = "contig"      # La columna de unión
)

dim(GS_degs_GO) # Columnas: "contig" y "Terminos_GO" Tiene 116 genes. ¿Por qué menos que 163? Porque algunos genes no tienen anotación GO.
write.table(GS_degs_GO, file="GS_degs_GO.txt", sep="\t", quote=F)
write.table(GS_degs_GO, file="GS_degs_GO.tsv", sep="\t", quote=F)



#generate the heats data for GOWMU
heats<-mutate(as.data.frame(resMF),negP=-log(pvalue)) # resMF contiene resultados de DESeq2 para cada gen dif. expresado.
heats<-mutate(heats,signedlogP=case_when(log2FoldChange<0 ~ negP*-1, log2FoldChange>0 ~ negP))
heats$genes<-rownames(resMF)
heats<-select(heats, signedlogP, genes)
heats<- heats[,c("genes", "signedlogP")]


write.table(heats, "PVals_GOWMU_Collapsed.csv", sep=",", row.names = FALSE, quote=FALSE)

New_resMF <- heats[1:5000, ]
dim(New_resMF)

write.table(New_resMF, "NEW_PVals_GOWMU_Collapsed.csv", sep=",", row.names = FALSE, quote=FALSE)


colnames(GS_degs_IDs) <- "genes"
colnames(GS_degs_IDs)

GS_genes_degs <- inner_join(
    GS_degs_IDs,          # Tabla de origen (163 DEGs)
    heats,     # Tabla de destino (Anotaciones de todo el genoma)
    by = "genes"      # La columna de unión
)

View(GS_genes_deg) # La tabla final tendrá solo dos columnas: "contig" y "Terminos_GO" 


#write.table(GS_genes_degs, "PVals_DEGs.tsv", sep="\t", row.names = TRUE, quote=FALSE)
write.table(GS_genes_degs, "PVals_DEGs.csv", sep=",", row.names = FALSE, quote=FALSE)


#### Hasta aquí quedamos con Maryam ####

# two columns of comma-separated values: gene id, continuous measure of significance. 
input="NEW_PVals_GOWMU_Collapsed.csv"
goAnnotations="data/coral_gene_GOannot.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. 
goDatabase="data/go.obo"
#download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("data/gomwu.functions.R")

test <- read.table("NEW_PVals_GOWMU_Collapsed.csv", sep = "\t", header = T, check.names = F)

#########################################################


#Crear un data frame con las asociaciones TérminoGO+funcion a partir del archivo .obo
# Cargar librería útil para manejo de texto
library(stringr)

# Ruta del archivo .obo
termID <- "data/go.obo"

obo <- readLines(termID)

term_start <- grep("^\\[Term\\]", obo)
term_end <- c(term_start[-1] - 1, length(obo))

ids <- c()
names <- c()

# Recorrer cada bloque y extraer id y name
for (i in seq_along(term_start)) {
  
  bloque <- obo[term_start[i]:term_end[i]]
  
  # Extraer id
  id_line <- bloque[grep("^id:", bloque)]
  id <- str_trim(sub("id:\\s*", "", id_line))
  
  # Extraer name
  name_line <- bloque[grep("^name:", bloque)]
  name <- str_trim(sub("name:\\s*", "", name_line))
  
  # Guardar
  ids <- c(ids, id)
  names <- c(names, name)
}

# Crear data frame final
term_df <- data.frame(
  GO_ID = ids,
  GO_name = names,
  stringsAsFactors = FALSE
)

write.table(term_df, "GO_term.txt", sep = "\t", row.names = FALSE, quote = FALSE)


# Data frame de las frecuencias de términos GO a partir de los degs.
# Cargar librerías necesarias
library(dplyr)
library(tidyr)

# Leer el archivo (ajusta el separador si es necesario)
datos <- read.table("GS_degs_GO.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)

# Separar los términos GO por ";"
go_df <- datos %>%
  filter(Terminos_GO != "unknown") %>%              # eliminar genes sin anotación
  separate_rows(Terminos_GO, sep = ";") %>%         # dividir cada término en filas
  group_by(Terminos_GO) %>%                         # agrupar por término GO
  summarise(Frecuencia = n(), .groups = "drop") %>% # contar frecuencia
  arrange(desc(Frecuencia))                         # ordenar de mayor a menor

# Mostrar los primeros resultados
head(go_df, 20)

# Si quieres guardar el resultado en un archivo .txt
write.table(go_df, "GO_frecuencias.txt", sep = "\t", row.names = FALSE, quote = FALSE)




#Unir GO_frecuencias con GO_term para obtener nombres de funciones

library(dplyr)

# Suponiendo que ya tienes cargados los data frames:
# go_df  -> con columnas Terminos_GO y Frecuencia
# term_df -> con columnas GO_ID y GO_name

# Unir ambos data frames por el identificador GO
go_df_full <- go_df %>%
  left_join(term_df, by = c("Terminos_GO" = "GO_ID")) %>%
  mutate(Termino_funcion = paste(Terminos_GO, GO_name, sep = "_"))

# Ver los primeros resultados
head(go_df_full)

# Guardar el resultado en un archivo si lo deseas
write.table(go_df_full, "GO_frecuencias_con_funcion.txt", sep = "\t", row.names = FALSE, quote = FALSE)

# Preparar los datos para :
top20 <- go_df_full %>%
  filter(!is.na(GO_name)) %>%          # elimina los NA
  arrange(desc(Frecuencia)) %>%
  slice(1:20)

# Crear gráfico de barras horizontal
p <- ggplot(top20, aes(x = Frecuencia, y = reorder(GO_name, Frecuencia))) +
  geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
  labs(
    title = "Top 20 términos GO más frecuentes",
    x = "Frecuencia",
    y = "Función asociada"
  ) +
    theme_minimal(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 20),
    axis.text.x = element_text(size = 20),
    axis.title.x = element_text(size = 25, face = "bold"),  # tamaño título eje X
    axis.title.y = element_text(size = 25, face = "bold"),  # tamaño título eje Y
    plot.title = element_text(hjust = 0.5, size = 30, face = "bold")
  )

# Ajustar el ancho de la imagen al guardar
ggsave("GO_top20.png", plot = p, width = 20, height = 8, dpi = 300)



# Colapsar degs con GO y 
df_down 
df_up 


# nolint end